/**
 * In this sample script, we parse a text file that is uploaded to the script via an http request
 * Each line of the uses the CSV format and contains temperature _value,humidity_value,timestamp
 * The parsed content is used to create an array of JavaScript data structures that are published
 * to the dashboard, reflecting changes in real-time (as they arrive)
 * The implementation of this use case is a 5 steps process:
 * - step 1: get the attached file from the request
 * - step 2: (a) parse the file to extract the metrics and (b) save each record (temperature, humidity with same timestamp) into the data store
 * - step 3: publish the most recent readings to the temperature and humidity gauges on the dashboard
 * - step 4: query the data store for the last 20 historical readings 
 * - step 5: publish the historical reading to the line chart on the dashboard
 */

/*
 * STEP 1: get the attached file if any
 */

// "request" is an object that is automatically generated by scriptr.io when a script receives a request
// it contains multiple properties, such as notably the "files" property
// -- NOTE: In JavaScript a condition resolves to false if the tested variable is undefined, null, empty string, false or 0
// so the below instruction returns an empty array if the request did not contain any attached file -- END NOTE
if (!request.files) { 
    return [];
}

// if we are here, it means there is at least one attached file
// -- NOTE: the http protocol makes it is possible to post multiple files via an http request 
// using multiple "attachment" parameters, where each parameter can actually contain more than 
// one attached file -- END NOTE
// we assume there is only one attachment parameter, so we retrive the corresponding file list
var attachedFilesList = request.files[0]; 

// -- NOTE: if we know the name of this parameter, let's say for example it is "myfile", 
// an alternative to the above line is: var attachedFilesList = request.files.myFile; -- END NOTE

// we assume there is only one file attached through this parameter and we retrieve 
// the corresponding file data structure that is generated by scriptr.io 
var metricFileDataStructure = attachedFilesList[0]; 

// store the name of the file into a local variable (we don't really need this)
var fileName = metricFileDataStructure.fileName;

// store the content of the file into a local variable
var content = metricFileDataStructure.content;

/*
 * STEP 2: parse the content of the file and save each record in the data store
 */

// step 2.a

// as a first step, we split that content into lines, assuming '\r\n' (carriage return, line feed)
// as line separator, 
var lines = content.split("\r\n"); 

// if there is no content, we return an empty array
if (!lines) {
    return [];
}

// if we are here, this means we found some content, therefore:
// the second step is to loop through the lines and parse each line assuming ',' as value separator. 
// In each iteration, we will: \
// - create a JavaScript data structure ("JSON") using the values that are parsed from each line
// - store the JavaScript data structure into an array ("metricArray")

// - this is for step 2.b - we load the "document" module that allows us to save/query data into/from the data store
var document = require("document");

// we declare a variable that will contain the most recent reading
// we assume it is the last line of the file (in a sequential file)
var mostRecentReading;

// loop through the array of lines
for (var i = 0; i < lines.length; i++) {

    // split the line: this results in an array with 3 values [temperature, humidity, timestamp]
    var valuesArray = lines[i].split(",");

    // using the array of values, create a JavaScript data structure 
    var metricDataStructure = { 
        "temperature": valuesArray[0],
        "humidity": valuesArray[1],
        "timestamp": new Date(Number(valuesArray[2])) // turn the timestamp string into number then into a date
    };

    // step 2.b - save the data structure into scriptr.io's data store
    document.save(metricDataStructure);
    
    // if this is the last line of the file, set the "mostRecentReading" variable with the corresponding values
    if (i == lines.length - 1) {
    	mostRecentReading = metricDataStructure;
	}
}

/*
 * STEP 3: publish the most recent temperature and humidity reading to their respective
 * widget on the dahsboard, using the channel to which the dashboard is subscribed. 
 * We will target the "last_temperature" gauge and "last_humidity" gauge respectively
 * Reminder: to target a widget, we refer to the value of the "tag" property in the widget
 * -- NOTE: in scriptr.io, "channels" are powerful means to broadcast messages in real-time
 * to any subscribed entities, whether they are hosted by scriptr.io or remote entities
 */

// prepare the message structures for publishing. The exepcted format is:
// {"id": "<message tag value>", "result": "<static data structure>"}

var msgToTemperatureGauge = {
    "id": "last_temperature", // this is the value of the tag property of the line chart widget
    "result": mostRecentReading.temperature
};

var msgToHumidityGauge = {
    "id": "last_humidity", // this is the value of the tag property of the line chart widget
    "result": mostRecentReading.humidity
};

// invoke the native "publish" function, passing the name of the channel to publish to, and the msg
publish("responseChannel", msgToTemperatureGauge);
publish("responseChannel", msgToHumidityGauge);

/*
 * STEP 4: query the last 20 historical records from the data store
 */

// define the query parameters: query expression, fields filter, number of records to return
var queryParameters = {
    "query": "temperature is not null and humidity is not null", // our query expression
    "fields": "temperature, humidity, timestamp", // specify the fields we need. Note: some metadata was automatically added so we filter it
    "resultsPerPage": 20 // specify how many records max we want to be returned
};

// execute the query
// -- NOTE: the returned response contains 2 sections: "metadata" and "result". The former 
// informs the caller about the status of the execution. The latter contains the result
// if the execution was successful. -- END NOTE
var queryResponse = document.query(queryParameters);

// verify if an error was returned, if so, return the error
if (queryResponse.metadata.status == "failure") {
    return queryResponse.metadata;
}

// if no error, publish the returned document to the line chart
var msgToLineChart = {
    "id": "dataLineChart", // this is the value of the tag property of the line chart widget
    "result": queryResponse.result.documents
};

publish("responseChannel", msgToLineChart);

// return the array of values. this is optional in our example
return metricArray;